---
layout: post
title:  "Про помощь студентам в выполнении работ"
date:   2017-06-28 04:06:23 +0700
permalink: "freelance-students"
categories: [freelance,university,students]
---

~~Ести вам нужна помощь и вы считаете, что я соглашусь - пишите.~~

> На 2020 год предложение уже не актуально. Дипломы тоже не предлагать, зачастили.

## О чём эта статья?

+ Как я на это подписался
+ Плюсы такой работы
+ Её минусы

## Где заработать студенту, если не в собственном университете?

__Первый мой заказ__ был получен именно в нём. Дело было перед зимней сессией цена `2000 рублей`, курсовая около 1000 строк на `c++ builder 6`. Если честно, немного боялся, что не получится, ведь слово `Borland` я слышал в первый раз (к сожалению, не последний). Это было простенькое GUI для просмотра и сортировки маршрутов поездов. Получилось оно весьма неплохо, строились графики загрузки станций, и документация на русском была не самой плохой. Я потратил на это целый день (6-7 часов) и был доволен своей работой, как и заказчик.

После этого были другие заказы, приходившие от знакомых моих знакомых, ведь ответом на вопрос "Кто хорошо прогает?" неожиданно стал я. Это были не такие большие деньги, `от 300 до 500 рублей` иногда в бутылочном эквиваленте, всё уходило на еду, проезд, выпивку и цветы. Времени было много, найти позицию `junior` разработчика со свободным графиком было сложновато и рост моей карьеры продолжился не очень активно, а потом вновь вернулся к студенческим работам. Мой профиль на одной из бирж [здесь](https://studwork.org/info/80360).

## Как получить заказ за приличную цену на бирже студенческих работ

Когда я только начал, после первых же заказов я купил `vip`, чтобы знать предложения конкурентов. Ставки на заказы по `c++` и `c#` делилась на несколько категорий:
+ Задания от фирм перекупщиков и от самих студентов
+ Студенты делились на девочек, такие обычно быстро покупали ничего не уточняя, и на парней, думающих, что они наняли репетитора по c++ на круглосуточной основе
+ Перекупщики же делились на тех, кто давал хорошее ТЗ и/или поддерживал общение с студеном, и других: молчаливых, наглых и иногда просто невероятно глупых

По ценам:
+ Лабораторные за 150-300 обычно на обработку массивов/матриц
+ Паки лабораторных за весь семестр 7-8 штук по 300 за каждую
+ Сайты за 2.5-3 тыс. и сайты-дипломы 4-6 тыс. рублей
+ Онлайн помощь (полная лажа)
+ Работы с заранее утверждённой ставкой в 500
+ Сложные почти научные курсовые-дипломы за 15-20к

Из своего опыта могу сказать, что, сделав ставку в 500 и указав стек технологий из ТЗ вы почти что с `100% вероятностью` получаете заказ, тратя на него около часа. За заказ на работы за весь семестр выплату задержат, но вы получите знания по курсу за короткое время. Так, я получил заказ на `F#` по методичке `МФТИ` (7 работ по 500), сделал их почти сразу, получил знания и удовольствие от выполнения.
Самым прибыльным и не запарным был раздел `html`, где умственно отсталые птушники платили по 1000 рублей за скрипт в 40 строк или создание формы ввода, но заказы в нём были редко. Сайты до 3 тыс. тоже не пыльные.
Хоть я и мало времени уделяю работе, тем не менее мой `средний заработок` с учётом комиссий и т.п. составляет `200 рублей в час`. А максимальная стоимость кода `100 рублей за строку`.

## Почему я не планирую продолжать этим заниматься?

- Летом мало заказов
- Постоянно есть шанс наткнуться на человека, который будет спрашивать вас за каждую строчку кода
- Я пишу относительно хороший и свежий код, но не все преподаватели знают даже `std в c++` или `linq в c#`
- Хочется работать в команде и на постоянной работе
- Много времени уходит на поддержку и проверку почты (поиск заказов)

## Как выглядит моя самая дешевая работа

Больше я таких простых работ не брал.
{% highlight C++ %}
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <list>
#include <algorithm>

/**
 *  @author Nikita Fiodorov
 *  @site https://github.com/NikitaIT/
 *  @date 04.03.2017
 *  @price 125
 *  @build g++ -std=c++11 main.cpp
 */

/*!
 * \a Student _____ Group №_____
 * \date 04.03.2017
 */

/*!
 * \brief endOfProposals    Проверка на конец предложения
 * \param ch                Проверяемый смвол
 * \return 1                если символ конца предложения, 0 в пративном случае
 */
bool endOfProposals(char ch);

/*!
 * \brief extractProposals  Извлечь предложение
 * \param docin             Файл содержащий текст
 * \return                  Предложение
 */
std::string extractProposals(std::ifstream &docin);

/*!
 * \brief openDoc           Открыть файл исходного текста
 * \return                  Указатель на этот файл или nullptr если файл не найден
 */
std::ifstream * openDoc();

/*!
 * \brief buildProposalsList    Построение обращенного списка
 * \param docin                 Файл исходного текста
 * \param count                 Число считываемых строк
 * \return                      Список строк наоборот
 */
std::list<std::string> buildProposalsList(std::ifstream *docin, size_t count);

int main()
{
    //открываем файл
    auto docin = openDoc();
    if(docin==nullptr) return 0;
    //задаем колличество строк
    size_t count = 3;
    //строим список строк
    std::list<std::string> reverseProposalsList = buildProposalsList(docin, count);
    //выводим список в консоль
    std::for_each(reverseProposalsList.begin(),
                  reverseProposalsList.end(),
                  [](std::string p){ std::cout<< p; });
    getchar();
    return 0;
}

bool endOfProposals(char ch)
{
    return (ch == '.' || ch == '!' || ch == '?');
}

std::string extractProposals(std::ifstream &docin)
{
    char ch=' ';
    std::stringstream proposal;
    //пока не конец файла или предложения забераем символ
    while (!docin.eof()&&!endOfProposals(ch)) {
        docin.get(ch);
        proposal.put(ch);
    }
    return proposal.str();
}

std::ifstream * openDoc()
{
    std::string filepath = "C:/test.txt";
    std::cout<<"Enter the file name: ";
    std::cin>>filepath;
    std::ifstream *docin = new std::ifstream(filepath);
    if(!docin->is_open())
    {
        std::cout << "Error opening the file." << std::endl;
        getchar();
        docin = nullptr;
    }

    return docin;
}

std::list<std::string> buildProposalsList(std::ifstream *docin, size_t count)
{
    std::list<std::string> proposals;
    for(size_t i(0);i<count;i++){
        proposals.push_front(extractProposals(*docin));
    }
    return proposals;
}
{% endhighlight %}