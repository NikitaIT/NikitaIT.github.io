---
layout: post
title:  "Чистый код?"
date:   2017-08-13 15:46:23 +0700
permalink: "clean-code"
categories: [clean-code]
---

## Введение

Спустя 4 года почти непрерывной разработки я устал от плохого кода и усвоил много уроков. 
Я расскажу свою историю, я верю что она будет достаточно поучительной, но не обещаю что она будет не скучной.

## неПрофессионализм

Когда я только вошел в мир корпоративного программирования у меня была замечательная команда из 5 человек,
 тимлмд - невероятно начитанный приверженец школы мысли чистого кода и рефакторинга.

Так вот к чему я. Я ушел из этой крутой команды, с не менее круто написанного проекта ради большей зп и меньшей нагрузки.

Куда я попал? - В команду, даже я бы сказал 2 команды, где о чистом коде слышали максимум краем уха.

Это был шок, я ругался каждый день по нескольку раз работая с кодом.
Как писал Боб Мартин: 
> Единственная надежная метрика качества кода: колличество "чертей" в минуту (c) Чистый код. Введение

Это были не самые плохие команды, опытных разработчиков там было достаточно, 
однако у них у всех было четко сформировано представление о "правильном коде",
по этому у других эта метрика не давала о себе знать, 
там я усвоил первый урок тимлида с первой работы.

## Урок 1: pros cons

Пока вы не можете обьяснить `зачем` нужно сделать то что вы предлогаете - ваши предложения будут и должны быть отвергнуты.

На первой работе я частенько задавал вопросы вроде:
- Зачем мы используем `NHibernate`, ведь `Entity Framework` лучше, новее, его сейчас все используют.
- Давайте писать новый проект на `react`, а не на `jQuery`, даже создать этой библиотеки сказал что она мертва 
и её не стоит использовать в новых проектах.

> Тимлмд: Чем он лучше чем то что мы уже используем?
>
> Я: *невероятное бубнение*.
> 
> Я: Новые библиотеки позволят легче находить разработчиков.
> 
> Тимлмд: Тебя же как-то нашли.
> Если у нас появится ещё не одна технология которую нужно знать, то придется искать разработчика который знает и их - это сложнее. 
>
> Я: ...
>
> Я: Ну зачем-то новые библиотеки придумали и они стали популярны не просто так, значит они лучше старых!
>
> Тимлмд: Курение тоже стало популярно с открытием табака, это же не значит что люди стали здоровее?
>
> Я: *неловкое молчание*.

*Спустя 15 минут гугления*

> Я: `React` предоставляет абстракцию над DOM в виде JSX и позволяет быстро делать интерактивные интерфейсы!
> А `redux` делает общение между компонентами удобнее за счет использования централизованного хранилища.
>
> Тимлмд: А где в нашем проекте нужны такие интерфейсы? По моему нам хватает `eventbus` для общения компонентов. 
> Положить все данные в одно место - звучит странно, это породит сильное зацепление и слабую инкапсуляцию.
> 
> Я: Ладно, я как то не думал об этом. Но ведь `redux` это тоже `eventbus` вроде проблем быть не должно.

*Спустя 5 минут чтения документации* 

> Я, про себя: *кажется он прав, но `webpack` то точно был бы лучшим решением,
> чем сборщик `less` на `c#` и кастомный загрузчик модулей*
>
> Я: А почему мы не используем `webpack`(v1) и `babel`? 
> Нам приходится писать конфигурацию на `c#` и код на `es3` чтобы он работал в `ie6`.
> 
> Тимлмд: Разве тебе не хватает функциональности текущего сборщика для решения задач?
> 
> Я: Хватает.
>
> Тимлмд: Лучше писать код который точно работает в старом окружении, чем пологаться на транспилятор
> и потом постоянно проверять все ли в порядке. И вот мы добавим это, что ты предлогаешь делать с кодом? Переписать?
>
> Я: Ну можно только в новом проекте это добавить.
>
> Тимлмд: А если мы сейчас сделаем как ты хочешь, кто гарантирует что все будет так же или лучше чем раньше?
> Когда наберешь достаточно аргументов, поговорим, 
> а сейчас прекращай отвлекать меня от задач и работай, тебе я смотрю работы мало, что ты сидишь там думаешь не о том.

Таких разговоров у нас было много, тогда мне казалось, что я прав. Что нам нужны эти инструменты. 
Мои знакомые разработчики говорили что дурак мой тимлид, и что мне не повезло с проектом, 
и что технологии на нем допотопные, мол я после них работу не смогу найти.
Вы тоже могли так подумать. 

Сейчас я понимаю, что мой Тимлмд правильно ждал от меня больше аргументов. На том проекте не нужен был `react`, 
а `NHibernate` до сих пор остается лучшим выбором для проектов с продвинутым `DDD`. Тот же `babel` был слишком сырым, 
а стоимость внедрения `webpack` была выше выгод которые он давал для не `SPA`.

Способность понять все за и против и обьяснить их - самая важная часть любого знания.

Я часто вижу непонимание этого принципа у преподавателей и программистов, да вообще у людей.
На тысячу курсов и книг по программированию найдутся единицы в которых обьясняется не как делать что-то, 
а зачем нужно делать именно так. Это большая проблема современного образования. 

Люди не понимают, что изучение реализации не требует пояснений и не имеет никакой ценности. 
Условия влияющие на порядок выполнения и полезные свойства реализаций - вот что важно.
Вернее даже сказать полезные свойства этих условий и их совокупностей.

## Грандиозная переработка

Программист, пишуший чистый код, - это художник, 
преобразующий пустой экран в элегантно запрограммированную систему.

И это история о программировании холста(`<canvas>`).

Вернемся к тому времени когда я работал в компании №2. 
Спустя несколько месяцев и задач разрешимость которых оставалась под вопросом, 
было решено переписать основную библиотеку на которой был основан проект.
Это была библиотека визуализации графов с threejs код которой 
по большей части не трогали 10 лет, да, он был написан спустя 2 года
после того как веб разработчики вышли из пещер.

В этот раз были использованы удобный "новый" язык и инструмент, 
такими на тот момент являлись `typescript` и `rollup`.
Акцент ставился на то чтобы сделать код как можно более поддерживаемым, 
расширяемым и производительным. Были продолжительные дискуссии обо всём,
начиная от того какие правила использовать в `linter`, 
заканчивая тем как проектировать классы.

Именно классы. Это был тот уникальный случай, когда в front-end плюсы ООП были очевидны.

Они очевидны мне и сейчас, в других проектах, хотя многие front-end разработчики отрицают эти плюсы.

Все закончилось хорошо, мы внедрили библиотеку через пару месяцев.
Сначала её переписывал тот же программист, что писал прошлую версию. Экспертиза в `предметной области` 
и владение старой кодовой базой позволили ему быстро имплементировать самые сложные технические детали, 
вроде собственных шейдеров `webgl` и оптимизаций аллокации памяти.
Потом к нему присоединился и я, код был не идеален, но чистая архитектура была нами заложена.

В последствии это позволило сильно сократить кодовую базу приложения. 
Код покрывающий недостатки старой библиотеки глубоко укоренился в приложении, 
это произошло из-за того, что все поля всех классов(es3 функций) 
были публичными и ничто не мешало изменять поведение как угодно из вне. А сама библиотека была не человекочитаема.

Если бы чистый код не стоял во главе, то как писал Боб Мартин в одноименной главе - разработка бы затянулась, 
а на выходе получился такой же ком грязи как и в прошлой версии.

Вскоре я покинул и эту компанию с чистой совестью, полагаю `Правило Бойскаута` я выполнил.

## Вредные советы

Я люблю книгу Чистый код, но в ней есть и вредные советы.

#### Используйте исключения вместо возвращения кодов ошибок.

Правильный рецепт звучит так:
- Используйте монаду Result или Either для возвращения кодов проверяемых ошибок(исключений).
- Используйте исключения только в том случае, если вы не собираетесь их ловить, 
  т.е. для ситуаций в которых код написан не правильно.

В моделях предметной области используйте исключения, 
мы должны передавать в них заранее валидные данные. Если мы этого не делаем это ошибка в нашем коде. 
Это подчиняется принципу fail fast и мы не должны ловить исключения, 
не пробрасывая их дальше. 

Исключение для этого правила - код которым вы не управляете, 
он может быть спроектирован не правильно, если это так, оберните его в монаду, 
и только потом используйте.

При валидации данных, например при ожидаемой ошибке в `команде(cqs)` следует использовать монады.

Примечание: подход с монадами позволяет писать код без условных операторов в большенстве случаев

#### Называть методы getXXX/setXXX

Есть хороший принцип Uniform access principle, 
видимо упущенный дядей Бобом, но замеченный мной, при прочтении O-OSC Бертрана Мейера. 

> Все услуги, предлагаемые модулем, должны быть доступны через 
> унифицированную запись, в которой не указано, 
> реализованы ли они через хранилище или посредством вычислений

Т.е. не getXXX(), а XXX(). Не setXXX(xxx), а XXX(xxx).

В c# к счастью это можно сделать даже без скобок, 
остальные языки сильно от него отстают во всех планах.

Авторы вроде Егора Бугаенко могут порицать использование аксессоров, 
но когда они это делают имеется ввиду не "вообще не использовать", 
хотя звучит именно так, а делать приватные сеторы по умолчанию.

Аксессоры инкапсулируют в себе контракт доступа к полю. 
Этот контракт не зависит от окружения его вызывающего, 
по этому ему отведено 2 отдельных метода. 
В языках подобных c# внутреннее поле вообще может отсутствовать в явном виде.

#### Хотите проверить чувствуете ли вы чистый код?

Откройте книгу "Совершенный код" и найдите в ней как можно больше ошибок, уверяю вас там их достаточно.